#!/bin/sh

# Copyright 2019 Takuro Ashie <ashie@clear-code.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Find an available python command because recent systems install only
# "python3" instead of "python" by default. Note that """ means a block
# comment on Python, and ":" means no-op on shell script.

""":"
for cmd in python3 python; do
  $cmd -V > /dev/null 2>&1 && exec $cmd $0 "$@"
done

echo "Cannot find Python interpreter!"
exit 1
":"""

import os.path
import sys
import json
from gi import require_version as gi_require_version
gi_require_version('GLib', '2.0')
gi_require_version('IBus', '1.0')
from gi.repository import IBus
from gi.repository import GLib

loop = None
mode = None
context = None
modes_dict = None
modes_dict_default = {
    "anthy": {
        "on":            "InputMode.Hiragana",
        "active":        "InputMode.Hiragana",
        "hiragana":      "InputMode.Hiragana",
        "off":           "InputMode.Latin",
        "inactive":      "InputMode.Latin",
        "katakana":      "InputMode.Katakana",
        "half-katakana": "InputMode.HalfWidthKatakana",
        "latin":         "InputMode.Latin",
        "wide-latin":    "InputMode.WideLatin",
    },
    "kkc": {
        "on":            "InputMode.Hiragana",
        "active":        "InputMode.Hiragana",
        "hiragana":      "InputMode.Hiragana",
        "off":           "InputMode.Direct",
        "inactive":      "InputMode.Direct",
        "katakana":      "InputMode.Katakana",
        "half-katakana": "InputMode.HankakuKatakana",
        "latin":         "InputMode.Latin",
        "wide-latin":    "InputMode.WideLatin",
    },
    "mozc-jp": {
        "on":            "InputMode.Hiragana",
        "active":        "InputMode.Hiragana",
        "hiragana":      "InputMode.Hiragana",
        "off":           "InputMode.Direct",
        "inactive":      "InputMode.Direct",
        "katakana":      "InputMode.Katakana",
        "half-katakana": "InputMode.HalfWidthKatakana",
        "latin":         "InputMode.Latin",
        "wide-latin":    "InputMode.WideLatin",
    },
    "skk": {
        "on":            "InputMode.Hiragana",
        "active":        "InputMode.Hiragana",
        "hiragana":      "InputMode.Hiragana",
        "off":           "InputMode.Latin",
        "inactive":      "InputMode.Latin",
        "katakana":      "InputMode.Katakana",
        "half-katakana": "InputMode.HankakuKatakana",
        "latin":         "InputMode.Latin",
        "wide-latin":    "InputMode.WideLatin",
    },
}


def load_config_file(path):
    conf = dict()
    try:
        with open(path, "r") as f:
            conf.update(json.load(f))
    except Exception as e:
        pass
    return conf


def load_config_dir(confdir):
    conf = dict()
    try:
        files = os.listdir(confdir)
        for filename in files:
            path = os.path.join(confdir, filename)
            conf.update(load_config_file(path))
    except Exception as e:
        pass
    return conf


def load_config_path(path):
    conf = dict()
    if os.path.isdir(path):
        conf.update(load_config_dir(path))
    elif os.path.isfile(path):
        conf.update(load_config_file(path))
    return conf


def load_config():
    conf = dict(modes_dict_default)
    system_config_path = "/etc/ibus-set-input-mode"
    conf.update(load_config_path(system_config_path))
    user_config_path = os.path.expanduser("~/.config/ibus-set-input-mode")
    conf.update(load_config_path(user_config_path))
    return conf


def on_created(bus, result):
    context = bus.create_input_context_async_finish(result)
    if not context:
        sys.stderr.write("Cannot get context\n")
        sys.exit(1)
    context.set_capabilities(IBus.Capabilite.FOCUS | IBus.Capabilite.PROPERTY)
    context.focus_in()
    context.get_engine_async(-1, None, on_get_engine, context)


def on_get_engine(bus, result, context):
    engine = bus.get_engine_async_finish(result)
    if not engine:
        sys.stderr.write("Cannot get engine\n")
        sys.exit(1)

    engine_name = engine.get_name()
    if engine_name not in modes_dict:
        sys.stderr.write("Unknown engine: %s\n" % engine_name)
        sys.exit(1)

    modes = modes_dict[engine_name]

    if mode not in modes:
        sys.stderr.write("Unknown mode: %s\n" % mode)
        sys.exit(1)

    context.property_activate(modes[mode], IBus.PropState.CHECKED)
    GLib.timeout_add(50, lambda: loop.quit())


if (len(sys.argv) != 2):
    sys.stderr.write('''Usage: %s MODE
    MODE: on, off, hiragana, katakana, half-katakana, latin, wide-latin
'''
                     % sys.argv[0])
    sys.exit(1)

mode = sys.argv[1]
modes_dict = load_config()

IBus.init()
bus = IBus.Bus()
bus.create_input_context_async("ibus-set-input-mode",
                               -1, None, on_created)
loop = GLib.MainLoop()
GLib.timeout_add(1000, lambda: loop.quit())
loop.run()
